**CreateThread与_beginthreadex**
> CreateThread和_beginthreadex都是用于创建线程的函数，但它们之间存在一些重要的区别。
> 1. 底层实现：_beginthreadex函数实际上是通过调用CreateThread函数来实现的。也就是说，_beginthreadex是C++运行时提供的一个对线程进行初始化的函数，它创建线程并创建一个线程转悠数据块，而这个操作最终还是通过CreateThread来实现的。
> 2. 使用场景：在Console程序中一般使用CreateThread，而在win32和MFV程序中一般使用_beginthreadex。
> 3. 线程管理：_beginthreadex函数在执行完线程函数后会调用_endthreadex来释放线程专属数据块，避免内存泄漏，并调用ExitThread退出线程，将退出码写入到线程内核对象中。而CreateThread并没有这样的功能。
> &emsp;总的来说，CreateThread和_beginthreadex都是用于创建线程的函数，但_beginthreadex具有更完善的功能，包括线程的初始化、释放内存和退出处理。在特定场景下，比如win32和MFV程序，使用_beginthreadex可能更为合适。
> &emsp;CreateThread函数在创建新线程时，新线程会共享父进程的上下文，包括堆、栈、全局变量等。这意味着在父进程中分配的内存空间和全局变量可以在新线程中访问和修改。
> &emsp;而_beginthreadex函数在创建新线程时，会为新线程创建一个独立的进程上下文，与父进程的上下文相互隔离。这意味着新线程中的代码无法直接访问和修改父进程的堆、栈、全局变量等。这种隔离有助于增强线程的独立性和安全性，但同时也增加了线程间通信和数据共享的复杂性。
> &emsp;因此，在使用_beginthreadex函数时，需要特别注意线程间的数据共享和通信问题，避免出现数据竞争和错误的数据访问。可以通过使用共享内存、消息队列、事件等机制来实现线程间的数据共享和通信。
> 
> **例如**：如果你使用CreateThread函数来创建线程，临界区可以在不同线程之间起效。因为CreateThread函数创建的线程是操作系统级别的线程，它们共享相同的进程上下文，包括临界区。而如果使用_beginthreadex，其创建的线程是C运行时库线程，而不是操作系统线程。因此，它们不共享相同的进程上下文，也无法共享临界区。互斥信号量同理。

**CreateMutex**
> &emsp;CreateMutex创建的互斥量是进程内的互斥量，而不是进程间的互斥量。这意味着它只能在同一进程的不同线程之间提供互斥。
> &emsp;如果您想要在不同进程之间提供互斥，您可以考虑使用命名互斥量。通过给CreateMutex函数的第三个参数传递一个名字（字符串），您可以在不同进程之间共享这个互斥量。
> &emsp;然后，其他进程可以通过调用OpenMutex函数来打开这个命名互斥量，以便在不同进程之间提供互斥。
> &emsp;另外，您还可以考虑使用临界区（Critical Section）或信号量（Semaphore），它们也可以用于在不同进程之间提供互斥和同步。


**Event**
> &emsp;事件（Event）是一种同步对象，它可以用于在不同线程之间提供同步和通信。与互斥量不同，事件可以用于不同线程之间的同步，也可以用于不同进程之间的同步。
> &emsp;在Windows操作系统中，使用CreateEvent函数创建的事件可以是进程内的事件，也可以是进程间的事件，具体取决于函数的参数。
> &emsp;如果将lpName参数设置为NULL，则创建的是进程内的事件；如果将lpName参数设置为一个字符串，则创建的是进程间的事件。
> &emsp;进程间的事件可以通过名称来共享，其他进程可以通过调用OpenEvent函数来打开这个事件。
>
> **注意**：在Windows操作系统中，如果使用CreateEvent函数创建事件时，不设置lpName参数（即将lpName参数设置为NULL），则创建的事件是一个进程内的事件。
> &emsp;虽然它是进程内的事件，但是它仍然可以在不同线程之间起作用，也可以在不同进程之间起作用。
> 这是因为在Windows操作系统中，内核对象（如事件、互斥量、信号量等）是由内核统一管理的，它们的句柄是在内核空间中分配的。
> &emsp;因此，即使是进程内的事件，不同线程和不同进程都可以通过句柄来访问和操作它。
> &emsp;对于进程内的事件，在同一个进程中的不同线程可以共享这个事件，因为它们都可以访问同一个事件句柄。
> &emsp;而对于不同进程之间的事件，如果在创建事件时指定了lpName参数，那么其他进程可以通过OpenEvent函数来打开这个事件，从而实现进程间的同步和通信。
> &emsp;因此，即使你没有设置lpName参数，创建的事件依然可以在不同线程之间起作用，因为它们共享同一个事件句柄。
> &emsp;但如果你希望在不同进程之间使用事件进行同步和通信，你可以通过设置lpName参数来创建进程间的事件。


**WaitForSingleObject**
> &emsp;WaitForSingleObject函数在请求信号量时，如果当前信号量为0即不触发状态，那么线程进入阻塞状态，直到信号量值大于0该函数才返回，线程进入可调度状态，同时信号量值减一。因此，WaitForSingleObject会在信号量值大于0时让信号量减1。
> &emsp;**请注意**，信号量的值不可能小于0。