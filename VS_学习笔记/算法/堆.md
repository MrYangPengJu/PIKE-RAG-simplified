# 堆
## 最小优先队列
```C
#include <stdio.h>
#include <stdlib.h>

#define ElemType int



typedef struct MinPQ {
	ElemType* data;
	int size;
	int maxSize;
}MinPQ;



//基于堆的完全二叉树
//存储于data[1...N]中，data[0]没用使用
MinPQ* init(int maxSize)
{
	MinPQ* obj = (MinPQ*)malloc(sizeof(MinPQ));
	obj->data = (ElemType*)malloc(sizeof(ElemType) * (maxSize + 1));
	obj->maxSize = maxSize;
	obj->size = 0;
	return obj;
}
bool isEmpty(MinPQ* PQ)
{
	return (PQ->size) == 0;
}
int size(MinPQ* PQ)
{
	return PQ->size;
}

bool moreThan(ElemType* data, int i, int j)
{
	return data[i] > data[j];
}
void exch(ElemType* data, int i, int j)
{
	int temp = data[i]; data[i] = data[j]; data[j] = temp;
}
void swim(ElemType* data, int k)
{
	// 不停将子节点与父节点进行比较，如果子结点小于父节点，则交换顺序
	while (k > 1 && moreThan(data, k / 2, k))
	{
		exch(data, k / 2, k);
		k = k / 2;
	}
}
void sink(ElemType* data, int k, int size)
{
	while (k * 2 <= size)
	{
		int j = k * 2;
		if (j < size && moreThan(data, j, j + 1)) //在同一行中找出最小
			j++;
		if (!moreThan(data, k, j)) // 判断是否继续下沉
			break;
		exch(data, k, j);
		k = j;
	}
}
bool insert(MinPQ* PQ, ElemType val)
{
	if (PQ->size > PQ->maxSize)
		return false;
	PQ->data[++(PQ->size)] = val;
	// 通过上浮让其找到合适的位置
	swim(PQ->data, PQ->size);
	return true;
}
ElemType delMin(MinPQ* PQ)
{
	if (isEmpty(PQ))
		return false;
	ElemType min = PQ->data[1];
	// 将最大值与最后一个元素交换位置
	exch(PQ->data, 1, PQ->size);
	// 删除最后一个元素
	PQ->size--;
	// 通过下沉使得被交换的元素回到合适的位置，并且保证堆的性质
	sink(PQ->data, 1, PQ->size);
	return min;
}
int main()
{
	MinPQ* pq = init(100);
	insert(pq, 10);
	insert(pq, 1);
	insert(pq, 3);
	insert(pq, 5);
	insert(pq, 4);
	while (!isEmpty(pq))
	{
		printf("%d\n", delMin(pq));
	}

}

```

## 最大优先队列(将moreThan改为lessThan即可)
```C
#include <stdio.h>
#include <stdlib.h>

#define ElemType int



typedef struct MaxPQ {
	ElemType* data;
	int size;
	int maxSize;
}MaxPQ;



//基于堆的完全二叉树
//存储于data[1...N]中，data[0]没用使用
MaxPQ* init(int maxSize)
{
	MaxPQ* obj = (MaxPQ*)malloc(sizeof(MaxPQ));
	obj->data = (ElemType*)malloc(sizeof(ElemType) * (maxSize + 1));
	obj->maxSize = maxSize;
	obj->size = 0;
	return obj;
}
bool isEmpty(MaxPQ* PQ)
{
	return (PQ->size) == 0;
}
int size(MaxPQ* PQ)
{
	return PQ->size;
}

bool lessThan(ElemType* data, int i, int j)
{
	return data[i] < data[j];
}
void exch(ElemType* data, int i, int j)
{
	int temp = data[i]; data[i] = data[j]; data[j] = temp;
}
void swim(ElemType* data, int k)
{
	// 不停将子节点与父节点进行比较，如果子结点小于父节点，则交换顺序
	while (k > 1 && lessThan(data, k / 2, k))
	{
		exch(data, k / 2, k);
		k = k / 2;
	}
}
void sink(ElemType* data, int k, int size)
{
	while (k * 2 <= size)
	{
		int j = k * 2;
		if (j < size && lessThan(data, j, j + 1)) //在同一行中找出最小
			j++;
		if (!lessThan(data, k, j)) // 判断是否继续下沉
			break;
		exch(data, k, j);
		k = j;
	}
}
bool insert(MaxPQ* PQ, ElemType val)
{
	if (PQ->size > PQ->maxSize)
		return false;
	PQ->data[++(PQ->size)] = val;
	// 通过上浮让其找到合适的位置
	swim(PQ->data, PQ->size);
	return true;
}
ElemType delMax(MaxPQ* PQ)
{
	if (isEmpty(PQ))
		return false;
	ElemType max = PQ->data[1];
	// 将最大值与最后一个元素交换位置
	exch(PQ->data, 1, PQ->size);
	// 删除最后一个元素
	PQ->size--;
	// 通过下沉使得被交换的元素回到合适的位置，并且保证堆的性质
	sink(PQ->data, 1, PQ->size);
	return max;
}
int main()
{
	MaxPQ* pq = init(100);
	insert(pq, 10);
	insert(pq, 1);
	insert(pq, 3);
	insert(pq, 5);
	insert(pq, 4);
	while (!isEmpty(pq))
	{
		printf("%d\n", delMax(pq));
	}

}
```