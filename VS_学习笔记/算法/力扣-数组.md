> 数组中的第K个最大元素 - 解题思路
> 利用快速排序的思想，从数组 S 中随机找出一个元素 X，把数组分为两部分 Sa 和 Sb。Sa 中的元素大于等于 X，Sb 中元素小于 X。这时有两种情况：
> Sa 中元素的个数小于 k，则 Sb 中的第 k-|Sa| 个元素即为第k大数；
> Sa 中元素的个数大于等于 k，则返回 Sa 中的第 k 大数。时间复杂度近似为 O(n)

```Python
class Solution:
    # 采用快速排序方法，分成的数列左边大于右边
    def findKthLargest(self, nums, k):
        n = len(nums)
        if (k > n):
            return
        index = self.quickSort(nums, 0, n-1, k)
        return nums[index]
        
        
    def quickSort(self, nums, l, r, k):
        # 在快速排序的过程中，我们始终在寻找第k大的数值,nums始终未变,因此在递归调用中，k的值应该保持不变
        if l >= r:
            return l
        p = self.partition(nums, l, r)
        if p + 1 == k:
            return p
        if p + 1 > k:
            return self.quickSort(nums, l, p -1, k)
        else:
            return self.quickSort(nums, p + 1, r, k)


    def partition(self, nums, l, r):
        # 以最左边的元素作为分割元素
        v = nums[l]
        j = l
        i = l + 1
        # i为探测指针，j左边为大于等于v的数值，右边是小于v的数值
        while i <= r:
            # 通过维护数组相队顺序，使得只需要一个指针就能完成任务
            # 只要元素大于等于v就让其跑到j的前面去
            if nums[i] >= v:
                nums[j+1],nums[i] = nums[i],nums[j+1]
                j += 1
            i += 1
        # 最后让分割元素回到正确位置
        nums[l], nums[j] = nums[j], nums[l]
        return j
```