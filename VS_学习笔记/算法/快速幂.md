## 快速幂

**储备知识**
> (a + b) % p = (a % p + b % p) % p 
> (a - b) % p = (a % p - b % p) % p 
> (a * b) % p = (a % p * b % p) % p 

> &emsp;&emsp;其中我们只要关注第“3”条法则即可：$(a * b) \% p = (a \% p * b \% p) \% p$ ，我们仔细研究一下这个运算法则，会发现多个因子连续的乘积取模的结果等于每个因子取模后的乘积再取模的结果。也就是说，我们如果要求：
&emsp;&emsp;&emsp;$ (a*b*c)\%d=(a\%d*b\%d*c\%d)\%d;$
&emsp;&emsp;因此，我们可以借助这个法则，只需要在循环乘积的每一步都提前进行“取模”运算，而不是等到最后直接对结果“取模”，也能达到同样的效果。
&emsp;&emsp;所以，我们的代码可以变成这个样子：
```C++
/**
 * 普通的求幂函数
 * @param base 底数
 * @param power  指数
 * @return  求幂结果的最后3位数表示的整数
 */
long long normalPower(long long base,long long power){
    long long result=1;
    for(int i=1;i<=power;i++){
        result=result*base;
        result=result%1000;
    }
    return result%1000;
}
```

> 快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。
> 算法思想：
> 当指数为偶数时，幂减半，原式 = (底数*底数)^(减半后的幂)
> 当指数为奇数时，幂-1，原式 = (底数)^(幂-1)*底数

```C++
// 如果lastNum为1000，则取结果的后三位
long long fastPower(long long base, long long power, long long lastNum) {
    long long result = 1;
    while (power > 0) {
        if (power % 2 == 0) {
            //如果指数为偶数
            power = power / 2;//把指数缩小为一半
            base = base * base % lastNum;//底数变大成原来的平方
        } else {
            //如果指数为奇数
            power = power - 1;//把指数减去1，使其变成一个偶数
            result = result * base % lastNum;//此时记得要把指数为奇数时分离出来的底数的一次方收集好
            power = power / 2;//此时指数为偶数，可以继续执行操作
            base = base * base % lastNum;
        }
    }
    return result;
}
```

以上代码进行优化：
```C++
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power & 1) {//此处等价于if(power%2==1)
            result = result * base % 1000;
        }
        power >>= 1;//此处等价于power=power/2
        base = (base * base) % 1000;
    }
    return result;
}
```