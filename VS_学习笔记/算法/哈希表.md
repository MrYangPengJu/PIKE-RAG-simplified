# 哈希表
## 当key为数字，非对象时，可使用以下哈希函数：
```C
int hash32shift(int key)
{
    //key = ~key + (key << 15); 
    key = (key << 15) - key - 1;
    key = key ^ (key >> 12);
    key = key + (key << 2);
    key = key ^ (key >> 4);
    //key = key * 2057; 
    key = (key + (key << 3)) + (key << 11);
    key = key ^ (key >> 16);
    return key;
}
```



## 当key为对象时，可使用以下哈希函数(需传入唯一的地址)
```C
#include <stdint.h>
uint32_t murmur3_32(const uint8_t* key, size_t len, uint32_t seed) {
    const uint32_t c1 = 0xcc9e2d51;
    const uint32_t c2 = 0x1b873593;
    const uint32_t r1 = 15;
    const uint32_t r2 = 13;
    const uint32_t m = 5;
    const uint32_t n = 0xe6546b64;

    uint32_t hash = seed;

    const int nblocks = len / 4;
    const uint32_t* blocks = (const uint32_t*)key;
    for (int i = 0; i < nblocks; i++) {
        uint32_t k = blocks[i];
        k *= c1;
        k = (k << r1) | (k >> (32 - r1));
        k *= c2;

        hash ^= k;
        hash = ((hash << r2) | (hash >> (32 - r2))) * m + n;
    }

    const uint8_t* tail = (const uint8_t*)(key + nblocks * 4);
    uint32_t k1 = 0;

    switch (len & 3) {
    case 3:
        k1 ^= tail[2] << 16;
    case 2:
        k1 ^= tail[1] << 8;
    case 1:
        k1 ^= tail[0];

        k1 *= c1;
        k1 = (k1 << r1) | (k1 >> (32 - r1));
        k1 *= c2;
        hash ^= k1;
    }

    hash ^= len;
    hash ^= (hash >> 16);
    hash *= 0x85ebca6b;
    hash ^= (hash >> 13);
    hash *= 0xc2b2ae35;
    hash ^= (hash >> 16);

    return hash;
}


uint32_t fnv1a_32(const uint8_t* data, size_t len) {
    const uint32_t FNV_prime = 16777619;
    uint32_t hash = 2166136261;

    for (size_t i = 0; i < len; i++) {
        hash ^= data[i];
        hash *= FNV_prime;
    }

    return hash;
}

uint32_t jenkins_one_at_a_time_hash(const uint8_t* key, size_t length) {
    uint32_t hash, i;
    for (hash = i = 0; i < length; ++i) {
        hash += key[i];
        hash += (hash << 10);
        hash ^= (hash >> 6);
    }
    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);
    return hash;
}
```


## 可使用的insert以及find函数如下(线性探测法和拉链法)：
```C
#define ElemType int

typedef struct HashNode {
    int key;
    ElemType val;
    bool occupied;
}HashNode;
typedef struct HashTable {
    HashNode* data;
    int size;
}HashTable;

typedef struct HashLinkNode {
    int key;
    ElemType val;
    struct HashLinkNode* next;
}HashLinkNode;
typedef struct HashLinkTable {
    HashLinkNode** tables;
    int size;
}HashLinkTable;

HashTable* init(int size)
{
    HashTable* obj = (HashTable*)malloc(sizeof(HashTable));
    obj->data = (HashNode*)malloc(sizeof(HashNode) * size);
    for (int i = 0; i < size; i++)
        obj->data[i].occupied = false;
    obj->size = size;
    return obj;
}
HashLinkTable* hashLinkInit(int size)
{
    HashLinkTable* obj = (HashLinkTable*)malloc(sizeof(HashLinkTable));
    obj->tables = (HashLinkNode**)malloc(sizeof(HashLinkNode*) * size);
    for (int i = 0; i < size; i++)
    {
        obj->tables[i] = (HashLinkNode*)malloc(sizeof(HashLinkNode));
        obj->tables[i]->next = NULL;
    }
    obj->size = size;
    return obj;
}

// 线性探测
bool insert(HashTable* obj, int key, ElemType val)
{
    int hash = hashFunc(key, obj->size);
    if (obj->data[hash].occupied)
    {
        int tp = hash;
        hash++;
        while (hash % obj->size != tp)
        {
            if (!obj->data[hash].occupied || obj->data[hash].key == key)
                break;
            hash++;
        }
        return false;
    }
    obj->data[hash].occupied = true;
    obj->data[hash].key = key;
    obj->data[hash].val = val;
    return true;
}
ElemType find(HashTable* obj, int key)
{
    int hash = hashFunc(key, obj->size);
    if (obj->data[hash].key != key)
    {
        int tp = hash;
        hash++;
        while (hash % obj->size != tp)
        {
            if (obj->data[hash].key == key)
                break;
            hash++;
        }
        return false;
    }
    return obj->data[hash].val;
}
// 拉链法
void insert(HashLinkTable* obj, int key, ElemType val)
{
    int hash = hashFunc(key, obj->size);
    HashLinkNode* head = obj->tables[hash];
    while (head->next!=NULL && key != head->key)
        head = head->next;
    if (head->key == key)
        head->val = val;
    else
    {
        HashLinkNode* newNode = (HashLinkNode*)malloc(sizeof(HashLinkNode));
        newNode->key = key;
        newNode->val = val;
        newNode->next = NULL;
        head->next = newNode;
    }

}

ElemType find(HashLinkTable* obj, int key)
{
    int hash = hashFunc(key, obj->size);
    HashLinkNode* head = obj->tables[hash];
    while (head->next!=NULL)
    {
        head = head->next;
        if (head->key == key)
            return head->val;
    }
    return false;
}
```
