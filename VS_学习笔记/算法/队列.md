# 队列

## 顺序队列


```C
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 10
#define ElemType int

typedef struct {
    ElemType* data;
    int front;
    int rear;
} Queue;

Queue* init(int size) {
    Queue* obj = (Queue*)malloc(sizeof(Queue)*size);
    obj->front = -1;
    obj->rear = -1;
}

bool isEmpty(Queue* queue) {
    return queue->front == -1;
}

bool isFull(Queue* queue) {
    return queue->rear == MAX_SIZE - 1;
}

bool enqueue(Queue* queue, ElemType item) {
    if (isFull(queue)) {
        printf("Queue is full. Cannot enqueue.\n");
        return false;
    }
    if (isEmpty(queue)) {
        queue->front = 0;
    }
    queue->rear++;
    queue->data[queue->rear] = item;
    return true;
}

ElemType dequeue(Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Cannot dequeue.\n");
        return false;
    }
    ElemType item = queue->data[queue->front];
    if (queue->front == queue->rear) {
        queue->front = -1;
        queue->rear = -1;
    }
    else {
        queue->front++;
    }
    return item;
}


```


## 循环队列



```C
#include <stdio.h>
#include <stdlib.h>

#define ElemType int 
// 为了判断循环队列是否为满，需要浪费一个空间来区分队列为空和队列为满的情况
// 被浪费的空间不一定是最后一个元素，它可以是任意一个元素，只要取决于在哪判断为满或为空
// 取值 [front,rear)
typedef struct
{
	ElemType* data;
	int front;
	int rear;
	int size;
}cirQue;

bool isFull(cirQue* obj);
bool isEmpty(cirQue* obj);

cirQue* cirQueInit(int size)
{
	cirQue* obj = (cirQue*)malloc(sizeof(cirQue));
	obj->front = obj->rear = 0;
	obj->data = (int*)malloc(sizeof(int) * (size + 1));
	obj->size = size;
	return obj;
}
bool enQueue(cirQue* obj, ElemType value)
{
	if (isFull(obj))
		return false;
	obj->data[obj->rear++] = value;
	obj->rear %= (obj->size + 1);
	return true;
}
ElemType deQueue(cirQue* obj)
{
	if (isEmpty(obj))
		return false;
	ElemType ret = obj->front;
	obj->front++;
	obj->front %= (obj->size + 1);
	return ret;
}
ElemType getFront(cirQue* obj)
{
	if (!isEmpty(obj))
		return obj->data[obj->front];
	else
		return false;
}
ElemType getRear(cirQue* obj)
{
	if (!isEmpty(obj))
	{
		// 如果为0，说明元素在队列的尾部
		if (obj->rear == 0)
		{
			return obj->data[obj->rear + obj->size];
		}
		else
		{
			return obj->data[obj->rear - 1];
		}
	}
	else
		return false;
}
bool isEmpty(cirQue* obj)
{
	return obj->front == obj->rear;
}
bool isFull(cirQue* obj)
{
	return (obj->rear + 1) % (obj->size + 1) == obj->front;
}
void freeQueue(cirQue* obj)
{
	free(obj->data);
	free(obj);
}

```


## 链表队列
```C
#include <stdio.h>
#include <stdlib.h>

#define ElemType int

/*链式队列结点*/
typedef struct LinkNode{
	ElemType data;
	struct LinkNode* next;
}LinkNode;
/*链式队列*/
typedef struct {
	LinkNode* front, * rear;	//队列的队头和队尾指针
}LinkQueue;


LinkQueue* InitQueue() {
	LinkQueue* obj = (LinkQueue*)malloc(sizeof(LinkQueue));
	obj->front = obj->rear = (LinkNode*)malloc(sizeof(LinkNode));	//建立头结点
	obj->front->next = NULL;	//初始为空
	return obj;
}
bool isEmpty(LinkQueue* Q)
{
	return Q->front == Q->rear;
}
bool EnQueue(LinkQueue* Q, ElemType value) {
	LinkNode* node = (LinkNode*)malloc(sizeof(LinkNode));
	node->data = value;
	node->next = NULL;
	Q->rear->next = node;	//把拥有元素value新结点node赋值给原队尾结点的后继
	Q->rear = node;	//把当前的s设置为新的队尾结点
	return true;
}

bool DeQueue(LinkQueue* Q) {
	if (isEmpty(Q)) {
		return false;
	}
	LinkNode* p = Q->front->next;	//将欲删除的队头结点暂存给p
	ElemType ret = p->data;	//将欲删除的队头结点的值赋值给e
	Q->front->next = p->next;	//将原队头结点的后继赋值给头结点后继
	//若删除的队头是队尾，则删除后将rear指向头结点
	if (Q->rear == p) {
		Q->rear = Q->front;
	}
	free(p);
	return ret;
}


```
