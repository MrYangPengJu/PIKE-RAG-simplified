**线段树的构造**
```C++
void build(int id,int l,int r)//创建线段树,id表示存储下标,区间[L,r]
{
  if(l == r)//左端点等于右端点，即为叶子节点(区间长度为1)，直接赋值即可
  {
    tree[id] = data[l];
    return ;
  }
// 否则将当前区间中间拆开成两个区间
  int mid = (l + r) / 2;//mid则为中间点，左儿子的结点区间为[l,mid],右儿子的结点区间为[mid + 1,r]
  build(id * 2,l,mid); //递归构造左儿子结点
  build(id * 2 + 1,mid + 1,r); //递归构造右儿子结点
// 左右两个区间计算完成以后
// 合并到当前区间
  tree[id] = min(tree[id * 2],tree[id * 2 + 1]);//更新父节点
}
```

**单点更新**
```C++
// id 表示树节点编号，l r 表示这个节点所对应的区间
// 将 data[x] 修改为 v
// 线段树单点更新
void Single_point_of_updating(int id, int l, int r, int x, int v)
{
// 找到长度为 1 的区间才返回
  if (l == r)
  {
    tree[id] = v;
    return;
  }
//否则找到 x 在左区间或者右区间去更新
  int mid = (l + r) / 2;
  if (x <= mid) Single_point_of_updating(id * 2, l, mid, x, v);// 需要修改的值在左区间
  else Single_point_of_updating(id * 2 + 1, mid + 1, r, x, v);// 需要修改的值在右区间
  tree[id] = max(tree[id * 2], tree[id * 2 + 1]);
}
```

**区间更新（需要使用Lazy标记）**
```C++
void push_up(int id)
{
  tree[id] = tree[id * 2] + tree[id * 2 + 1];
}
void push_down(int id,int l,int r)
{
  if(lazy[id])//如果id有lazy标记
  {
    int mid = (l + r) / 2;
    lazy[id * 2] += lazy[id];//将它的左孩子的lazy加上它的lazy
    lazy[id * 2 + 1] += lazy[id];//将它的右孩子的lazy加上它的lazy
    tree[id * 2] += lazy[id] * (mid - l + 1);//左孩子的Q+它下放的Q*区间长度
    tree[id * 2 + 1] += lazy[id] * (r - mid);
    lazy[id] = 0;//清空lazy标记
  }
}
void Interval_updating(int id,int l,int r,int x,int y,int v)//id:目前查到的节点编号  目前区间为[l,r]  目标是讲[x,y]的所有数+v
{
  if(l >= x && r <= y)//[l,r]被[x,y]包含了
  {
    lazy[id] += v;//暂时不下放Q,加进lazy标记中
    tree[id] += v * (r - l + 1);//将Q收入囊中
    return ;
  }
  push_down(id,l,r);//要来更新下面节点了,赶紧下放Q
  int mid = (l + r) / 2;
  if(x <= mid) Interval_updating(id * 2,l,mid,x,y,v);//因为只有x<=mid(即[l,mid]有一部分是被[x,y]覆盖了的)才需要去更新[l,mid]
  if(y > mid) Interval_updating(id * 2 + 1,mid + 1,r,x,y,v);
  push_up(id);//子节点更新完之后父节点当然也要更新(上升操作)
}
```

**查询**
```C++
int find(int id,int l,int r,int x,int y)//id:目前查到的节点编号  目前区间为[l,r]  目标是求出[x,y]的和
{
  if(x <= l && r <= y) return tree[id];//[l,r]被[x,y]包含了
  push_down(id,l,r);//要查到id的子节点了,赶紧下放
  int mid = (l + r) / 2,ans = 0;
  if(x <= mid) ans += find(id * 2,l,mid,x,y);//ans+=左孩子和
  if(y > mid) ans += find(id * 2 + 1,mid + 1,r,x,y);//ans+=右孩子和
  return ans;
}
```